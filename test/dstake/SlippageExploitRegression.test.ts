import { expect } from "chai";
import { ethers, deployments } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("DStake Slippage Exploit Regression Test", function () {
  let alice: SignerWithAddress;
  let dStakeToken: any;
  let dStable: any;
  let router: any;
  let metaMorphoAdapter: any;
  let metaMorphoVault: any;
  let collateralVault: any;

  beforeEach(async function () {
    [alice] = await ethers.getSigners();

    // Use the standard deployment fixture
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeTokenV2_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVaultV2_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeTokenV2", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVaultV2", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    metaMorphoVault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    metaMorphoAdapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    // Setup permissions
    const MINTER_ROLE = await dStable.MINTER_ROLE();
    await dStable.grantRole(MINTER_ROLE, alice.address);

    // Configure router with MetaMorpho vault so deposits have an active target
    const VAULT_MANAGER_ROLE = await router.VAULT_MANAGER_ROLE();
    const ADAPTER_MANAGER_ROLE = await router.ADAPTER_MANAGER_ROLE();
    const CONFIG_MANAGER_ROLE = await router.CONFIG_MANAGER_ROLE();
    const ROUTER_DEFAULT_ADMIN_ROLE = await router.DEFAULT_ADMIN_ROLE();
    const hasAdminRole = await router.hasRole(ROUTER_DEFAULT_ADMIN_ROLE, alice.address);
    let adminSigner = alice;
    if (!hasAdminRole) {
      const routerAdmin = routerDeployment.receipt?.from;
      if (!routerAdmin) {
        throw new Error("Unable to determine router admin");
      }
      adminSigner = await ethers.getImpersonatedSigner(routerAdmin);
      await alice.sendTransaction({ to: routerAdmin, value: ethers.parseEther("1") });
    }

    if (!(await router.hasRole(VAULT_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(VAULT_MANAGER_ROLE, alice.address);
    }
    if (!(await router.hasRole(ADAPTER_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(ADAPTER_MANAGER_ROLE, alice.address);
    }
    if (!(await router.hasRole(CONFIG_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(CONFIG_MANAGER_ROLE, alice.address);
    }

    const strategyShareAddress = await metaMorphoVault.getAddress();
    const adapterAddress = await metaMorphoAdapter.getAddress();

    if ((await router.strategyShareToAdapter(strategyShareAddress)) === ethers.ZeroAddress) {
      await router.connect(alice).addAdapter(strategyShareAddress, adapterAddress);
    }

    if (!(await router.vaultExists(strategyShareAddress))) {
      await router.connect(alice).addVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    } else {
      await router.connect(alice).updateVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    }

    await router.connect(alice).setDefaultDepositStrategyShare(strategyShareAddress);

    // Ensure adapter has non-zero slippage for this test
    // Set slippage to 1% (100 basis points)
    const DEFAULT_ADMIN_ROLE = await metaMorphoAdapter.DEFAULT_ADMIN_ROLE();
    await metaMorphoAdapter.grantRole(DEFAULT_ADMIN_ROLE, alice.address);
    await metaMorphoAdapter.connect(alice).setMaxSlippage(100);
  });

  describe("Deposit-Withdraw Cycle with Slippage", function () {
    it("should revert auto withdraws that would underpay the user", async function () {
      const depositAmount = ethers.parseEther("100");

      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);

      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      const sharesReceived = await dStakeToken.balanceOf(alice.address);
      expect(sharesReceived).to.be.gt(0n);

      const BASIS_POINTS = 1_000_000n;
      const withdrawalFeeBps = BigInt(await dStakeToken.withdrawalFeeBps());
      const feeAmount = (depositAmount * withdrawalFeeBps) / BASIS_POINTS;
      const expectedMaxRedeemable = depositAmount - feeAmount;

      const maxRedeemable = await dStakeToken.maxWithdraw(alice.address);
      expect(maxRedeemable).to.equal(expectedMaxRedeemable);

      await expect(
        dStakeToken.connect(alice).withdraw(depositAmount, alice.address, alice.address)
      ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxWithdraw");

      await expect(
        dStakeToken.connect(alice).withdraw(maxRedeemable, alice.address, alice.address)
      ).to.be.revertedWithCustomError(router, "NoLiquidityAvailable");

      const sharesAfter = await dStakeToken.balanceOf(alice.address);
      expect(sharesAfter).to.equal(sharesReceived);
    });

    it("should require solver withdrawals to budget for slippage", async function () {
      const depositAmount = ethers.parseEther("100");
      const vaultAddress = await metaMorphoVault.getAddress();

      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      const BASIS_POINTS = 1_000_000n;
      const withdrawalFeeBps = BigInt(await dStakeToken.withdrawalFeeBps());
      const denominator = BASIS_POINTS - withdrawalFeeBps;

      // Requesting the full deposit without accounting for slippage should fail
      const naiveRequest = [depositAmount];
      const naiveGross = ((depositAmount * BASIS_POINTS) + denominator - 1n) / denominator;
      const totalAssetsBefore = BigInt(await dStakeToken.totalAssets());
      const totalSharesBefore = BigInt(await dStakeToken.totalSupply());
      const naiveShares = (naiveGross * totalSharesBefore + totalAssetsBefore - 1n) / totalAssetsBefore;

      await expect(
        dStakeToken.connect(alice).solverWithdrawAssets(
          [vaultAddress],
          naiveRequest,
          naiveShares,
          alice.address,
          alice.address
        )
      ).to.be.reverted;

      const slippageAdjustedNet = depositAmount - depositAmount / 100n; // budget 1% below deposit
      const adjustedGross = ((slippageAdjustedNet * BASIS_POINTS) + denominator - 1n) / denominator;
      const adjustedShares = (adjustedGross * totalSharesBefore + totalAssetsBefore - 1n) / totalAssetsBefore;

      const aliceBalanceBefore = await dStable.balanceOf(alice.address);

      await dStakeToken.connect(alice).solverWithdrawAssets(
        [vaultAddress],
        [slippageAdjustedNet],
        adjustedShares,
        alice.address,
        alice.address
      );

      const aliceBalanceAfter = await dStable.balanceOf(alice.address);
      const netReceived = aliceBalanceAfter - aliceBalanceBefore;

      expect(netReceived).to.be.gte(slippageAdjustedNet - 1n);
      expect(netReceived).to.be.lt(depositAmount);
    });
  });
});
