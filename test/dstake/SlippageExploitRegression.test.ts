import { expect } from "chai";
import { ethers, deployments, getNamedAccounts } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { configureMetaMorphoRouter, ensureRole } from "./utils/configureMetaMorpho";

describe("DStake Slippage Exploit Regression Test", function () {
  let alice: SignerWithAddress;
  let dStakeToken: any;
  let dStable: any;
  let router: any;
  let metaMorphoAdapter: any;
  let metaMorphoVault: any;
  let collateralVault: any;

  beforeEach(async function () {
    [alice] = await ethers.getSigners();

    // Use the standard deployment fixture
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeTokenV2_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVaultV2_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeTokenV2", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVaultV2", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    metaMorphoVault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    metaMorphoAdapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    const namedAccounts = await getNamedAccounts();

    await configureMetaMorphoRouter({
      router,
      routerDeployment,
      collateralVault,
      collateralVaultDeployment,
      vault: metaMorphoVault,
      adapter: metaMorphoAdapter,
      operator: alice,
      namedAccounts,
    });

    const minterRole = await dStable.MINTER_ROLE();
    await ensureRole({ contract: dStable, deployment: dStableDeployment, role: minterRole, operator: alice, namedAccounts });

    // Ensure adapter has non-zero slippage for this test
    // Set slippage to 1% (100 basis points)
    const DEFAULT_ADMIN_ROLE = await metaMorphoAdapter.DEFAULT_ADMIN_ROLE();
    await ensureRole({ contract: metaMorphoAdapter, deployment: adapterDeployment, role: DEFAULT_ADMIN_ROLE, operator: alice, namedAccounts });
    await metaMorphoAdapter.connect(alice).setMaxSlippage(100);
  });

  describe("Deposit-Withdraw Cycle with Slippage", function () {
    it("should revert auto withdraws that would underpay the user", async function () {
      const depositAmount = ethers.parseEther("100");

      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);

      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      const sharesReceived = await dStakeToken.balanceOf(alice.address);
      expect(sharesReceived).to.be.gt(0n);

      const BASIS_POINTS = 1_000_000n;
      const withdrawalFeeBps = BigInt(await dStakeToken.withdrawalFeeBps());
      const feeAmount = (depositAmount * withdrawalFeeBps) / BASIS_POINTS;
      const expectedMaxRedeemable = depositAmount - feeAmount;

      const maxRedeemable = await dStakeToken.maxWithdraw(alice.address);
      // With dust tolerance and rounding, allow for minor discrepancies
      expect(maxRedeemable).to.be.closeTo(expectedMaxRedeemable, ethers.parseUnits("1", 0));

      await expect(dStakeToken.connect(alice).withdraw(depositAmount, alice.address, alice.address)).to.be.revertedWithCustomError(
        dStakeToken,
        "ERC4626ExceedsMaxWithdraw"
      );

      await expect(dStakeToken.connect(alice).withdraw(maxRedeemable, alice.address, alice.address)).to.be.revertedWithCustomError(
        dStable,
        "ERC20InsufficientBalance"
      );

      const sharesAfter = await dStakeToken.balanceOf(alice.address);
      expect(sharesAfter).to.equal(sharesReceived);
    });

    it("should require solver withdrawals to budget for slippage", async function () {
      const depositAmount = ethers.parseEther("100");
      const vaultAddress = await metaMorphoVault.getAddress();

      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      const BASIS_POINTS = 1_000_000n;
      const withdrawalFeeBps = BigInt(await dStakeToken.withdrawalFeeBps());
      const denominator = BASIS_POINTS - withdrawalFeeBps;

      // Requesting the full deposit without accounting for slippage should fail
      const naiveRequest = [depositAmount];
      const naiveGross = (depositAmount * BASIS_POINTS + denominator - 1n) / denominator;
      const totalAssetsBefore = BigInt(await dStakeToken.totalAssets());
      const totalSharesBefore = BigInt(await dStakeToken.totalSupply()) || 1n;
      const naiveShares = (naiveGross * totalSharesBefore + totalAssetsBefore - 1n) / totalAssetsBefore;

      await expect(router.connect(alice).solverWithdrawAssets([vaultAddress], naiveRequest, naiveShares, alice.address, alice.address))
        .to.be.reverted;

      const slippageAdjustedNet = depositAmount - depositAmount / 100n; // budget 1% below deposit
      const adjustedGross = (slippageAdjustedNet * BASIS_POINTS + denominator - 1n) / denominator;
      const adjustedShares = (adjustedGross * totalSharesBefore + totalAssetsBefore - 1n) / totalAssetsBefore;

      const aliceBalanceBefore = await dStable.balanceOf(alice.address);

      await router
        .connect(alice)
        .solverWithdrawAssets([vaultAddress], [slippageAdjustedNet], adjustedShares, alice.address, alice.address);

      const aliceBalanceAfter = await dStable.balanceOf(alice.address);
      const netReceived = aliceBalanceAfter - aliceBalanceBefore;

      expect(netReceived).to.be.gte(slippageAdjustedNet - 1n);
      expect(netReceived).to.be.lt(depositAmount);
    });
  });
});
