import { expect } from "chai";
import { ethers, deployments } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("DStake Slippage Exploit Regression Test", function () {
  let alice: SignerWithAddress;
  let bob: SignerWithAddress;
  let dStakeToken: any;
  let dStable: any;
  let router: any;
  let metaMorphoAdapter: any;
  let metaMorphoVault: any;
  let collateralVault: any;

  beforeEach(async function () {
    [alice, bob] = await ethers.getSigners();

    // Use the standard deployment fixture
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeToken_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVault_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeToken", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVault", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    metaMorphoVault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    metaMorphoAdapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    // Setup permissions
    const MINTER_ROLE = await dStable.MINTER_ROLE();
    await dStable.grantRole(MINTER_ROLE, alice.address);

    // Configure router with MetaMorpho vault so deposits have an active target
    const VAULT_MANAGER_ROLE = await router.VAULT_MANAGER_ROLE();
    const ADAPTER_MANAGER_ROLE = await router.ADAPTER_MANAGER_ROLE();
    const CONFIG_MANAGER_ROLE = await router.CONFIG_MANAGER_ROLE();
    const ROUTER_DEFAULT_ADMIN_ROLE = await router.DEFAULT_ADMIN_ROLE();
    const hasAdminRole = await router.hasRole(ROUTER_DEFAULT_ADMIN_ROLE, alice.address);
    let adminSigner = alice;
    if (!hasAdminRole) {
      const routerAdmin = routerDeployment.receipt?.from;
      if (!routerAdmin) {
        throw new Error("Unable to determine router admin");
      }
      adminSigner = await ethers.getImpersonatedSigner(routerAdmin);
      await alice.sendTransaction({ to: routerAdmin, value: ethers.parseEther("1") });
    }

    if (!(await router.hasRole(VAULT_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(VAULT_MANAGER_ROLE, alice.address);
    }
    if (!(await router.hasRole(ADAPTER_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(ADAPTER_MANAGER_ROLE, alice.address);
    }
    if (!(await router.hasRole(CONFIG_MANAGER_ROLE, alice.address))) {
      await router.connect(adminSigner).grantRole(CONFIG_MANAGER_ROLE, alice.address);
    }

    const strategyShareAddress = await metaMorphoVault.getAddress();
    const adapterAddress = await metaMorphoAdapter.getAddress();

    if ((await router.strategyShareToAdapter(strategyShareAddress)) === ethers.ZeroAddress) {
      await router.connect(alice).addAdapter(strategyShareAddress, adapterAddress);
    }

    if (!(await router.vaultExists(strategyShareAddress))) {
      await router.connect(alice).addVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    } else {
      await router.connect(alice).updateVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    }

    await router.connect(alice).setDefaultDepositStrategyShare(strategyShareAddress);

    // Ensure adapter has non-zero slippage for this test
    // Set slippage to 1% (100 basis points)
    const DEFAULT_ADMIN_ROLE = await metaMorphoAdapter.DEFAULT_ADMIN_ROLE();
    await metaMorphoAdapter.grantRole(DEFAULT_ADMIN_ROLE, alice.address);
    await metaMorphoAdapter.connect(alice).setMaxSlippage(100);
  });

  describe("Deposit-Withdraw Cycle with Slippage", function () {
    it("Should NOT allow withdrawing more than deposited when slippage is non-zero", async function () {
      const depositAmount = ethers.parseEther("100");

      // Mint dStable to Alice
      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);

      // Record initial balance
      const initialBalance = await dStable.balanceOf(alice.address);

      // Deposit 100 dStable
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);
      const balanceAfterDeposit = await dStable.balanceOf(alice.address);

      // Get shares received
      const sharesReceived = await dStakeToken.balanceOf(alice.address);
      expect(sharesReceived).to.be.gt(0);

       const maxRedeemable = await dStakeToken.maxWithdraw(alice.address);
       expect(maxRedeemable).to.be.lt(depositAmount);

      // Immediately withdraw the same amount (100 dStable)
      await expect(
        dStakeToken.connect(alice).withdraw(depositAmount, alice.address, alice.address)
      ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxRedeem");

      // Withdraw the maximum allowed amount instead
      await dStakeToken.connect(alice).withdraw(maxRedeemable, alice.address, alice.address);

      // Check final balance
      const finalBalance = await dStable.balanceOf(alice.address);
      const netReceived = finalBalance - balanceAfterDeposit;

      // CRITICAL: User should receive EXACTLY what they deposited (or slightly less due to fees)
      // They should NOT receive more than deposited
      expect(netReceived).to.be.lte(depositAmount);

      // Allow for small rounding errors or fees (0.1% tolerance)
      const tolerance = depositAmount / 1000n;
      expect(netReceived).to.be.closeTo(maxRedeemable, tolerance);
    });

    it("Should NOT allow exploiting slippage buffer through repeated cycles", async function () {
      const cycleAmount = ethers.parseEther("50");
      const cycles = 5;

      // Mint initial dStable to Alice
      const initialFunds = cycleAmount * 2n; // Extra buffer
      await dStable.mint(alice.address, initialFunds);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), ethers.MaxUint256);

      const startingBalance = await dStable.balanceOf(alice.address);

      // Perform multiple deposit-withdraw cycles
      for (let i = 0; i < cycles; i++) {
        // Deposit
        await dStakeToken.connect(alice).deposit(cycleAmount, alice.address);

        const cycleMax = await dStakeToken.maxWithdraw(alice.address);
        expect(cycleMax).to.be.lte(cycleAmount);

        await expect(
          dStakeToken.connect(alice).withdraw(cycleAmount, alice.address, alice.address)
        ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxRedeem");

        // Immediately withdraw
        await dStakeToken.connect(alice).withdraw(cycleMax, alice.address, alice.address);
      }

      const endingBalance = await dStable.balanceOf(alice.address);

      // CRITICAL: Balance should not increase through cycles
      // Any increase would indicate the exploit is still present
      expect(endingBalance).to.be.lte(startingBalance);

      // The balance should be close to starting (allowing for fees/rounding)
      const tolerance = (cycleAmount * BigInt(cycles)) / 100n; // 1% total tolerance
      expect(endingBalance).to.be.closeTo(startingBalance, tolerance);
    });

    it("Should handle withdrawals correctly when actual slippage occurs", async function () {
      const depositAmount = ethers.parseEther("200");

      // Setup: Deposit first
      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      // Simulate actual slippage in the vault
      // This would normally happen due to market conditions
      // For testing, we'll attempt withdrawal of full amount
      const withdrawAmount = depositAmount;

      // The withdrawal should either:
      // 1. Succeed and return exactly the requested amount, OR
      // 2. Revert if slippage is too high

      const balanceBefore = await dStable.balanceOf(alice.address);
      const maxRedeemable = await dStakeToken.maxWithdraw(alice.address);
      expect(maxRedeemable).to.be.lt(withdrawAmount);

      await expect(
        dStakeToken.connect(alice).withdraw(withdrawAmount, alice.address, alice.address)
      ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxRedeem");

      await dStakeToken.connect(alice).withdraw(maxRedeemable, alice.address, alice.address);

      const balanceAfter = await dStable.balanceOf(alice.address);
      const received = balanceAfter - balanceBefore;
      const tolerance = withdrawAmount / 1000n;
      expect(received).to.be.closeTo(maxRedeemable, tolerance);
      expect(received).to.be.lte(withdrawAmount);
    });
  });
});
