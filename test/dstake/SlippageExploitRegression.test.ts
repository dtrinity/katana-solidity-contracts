import { expect } from "chai";
import { ethers, deployments } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("DStake Slippage Exploit Regression Test", function () {
  let alice: SignerWithAddress;
  let bob: SignerWithAddress;
  let dStakeToken: any;
  let dStable: any;
  let router: any;
  let metaMorphoAdapter: any;
  let metaMorphoVault: any;
  let collateralVault: any;

  beforeEach(async function () {
    [alice, bob] = await ethers.getSigners();

    // Use the standard deployment fixture
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeToken_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVault_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeToken", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVault", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    metaMorphoVault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    metaMorphoAdapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    // Setup permissions
    const MINTER_ROLE = await dStable.MINTER_ROLE();
    await dStable.grantRole(MINTER_ROLE, alice.address);

    // Ensure adapter has non-zero slippage for this test
    // Set slippage to 1% (100 basis points)
    const DEFAULT_ADMIN_ROLE = await metaMorphoAdapter.DEFAULT_ADMIN_ROLE();
    await metaMorphoAdapter.grantRole(DEFAULT_ADMIN_ROLE, alice.address);
    await metaMorphoAdapter.connect(alice).setMaxSlippage(100);
  });

  describe("Deposit-Withdraw Cycle with Slippage", function () {
    it("Should NOT allow withdrawing more than deposited when slippage is non-zero", async function () {
      const depositAmount = ethers.parseEther("100");

      // Mint dStable to Alice
      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);

      // Record initial balance
      const initialBalance = await dStable.balanceOf(alice.address);

      // Deposit 100 dStable
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      // Get shares received
      const sharesReceived = await dStakeToken.balanceOf(alice.address);
      expect(sharesReceived).to.be.gt(0);

      // Immediately withdraw the same amount (100 dStable)
      await dStakeToken.connect(alice).withdraw(depositAmount, alice.address, alice.address);

      // Check final balance
      const finalBalance = await dStable.balanceOf(alice.address);
      const netReceived = finalBalance - initialBalance;

      // CRITICAL: User should receive EXACTLY what they deposited (or slightly less due to fees)
      // They should NOT receive more than deposited
      expect(netReceived).to.be.lte(depositAmount);

      // Allow for small rounding errors or fees (0.1% tolerance)
      const tolerance = depositAmount / 1000n;
      expect(netReceived).to.be.closeTo(depositAmount, tolerance);
    });

    it("Should NOT allow exploiting slippage buffer through repeated cycles", async function () {
      const cycleAmount = ethers.parseEther("50");
      const cycles = 5;

      // Mint initial dStable to Alice
      const initialFunds = cycleAmount * 2n; // Extra buffer
      await dStable.mint(alice.address, initialFunds);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), ethers.MaxUint256);

      const startingBalance = await dStable.balanceOf(alice.address);

      // Perform multiple deposit-withdraw cycles
      for (let i = 0; i < cycles; i++) {
        // Deposit
        await dStakeToken.connect(alice).deposit(cycleAmount, alice.address);

        // Immediately withdraw
        await dStakeToken.connect(alice).withdraw(cycleAmount, alice.address, alice.address);
      }

      const endingBalance = await dStable.balanceOf(alice.address);

      // CRITICAL: Balance should not increase through cycles
      // Any increase would indicate the exploit is still present
      expect(endingBalance).to.be.lte(startingBalance);

      // The balance should be close to starting (allowing for fees/rounding)
      const tolerance = (cycleAmount * BigInt(cycles)) / 100n; // 1% total tolerance
      expect(endingBalance).to.be.closeTo(startingBalance, tolerance);
    });

    it("Should handle withdrawals correctly when actual slippage occurs", async function () {
      const depositAmount = ethers.parseEther("200");

      // Setup: Deposit first
      await dStable.mint(alice.address, depositAmount);
      await dStable.connect(alice).approve(await dStakeToken.getAddress(), depositAmount);
      await dStakeToken.connect(alice).deposit(depositAmount, alice.address);

      // Simulate actual slippage in the vault
      // This would normally happen due to market conditions
      // For testing, we'll attempt withdrawal of full amount
      const withdrawAmount = depositAmount;

      // The withdrawal should either:
      // 1. Succeed and return exactly the requested amount, OR
      // 2. Revert if slippage is too high

      const balanceBefore = await dStable.balanceOf(alice.address);

      try {
        await dStakeToken.connect(alice).withdraw(withdrawAmount, alice.address, alice.address);

        const balanceAfter = await dStable.balanceOf(alice.address);
        const received = balanceAfter - balanceBefore;

        // If it succeeds, must return exactly what was requested (minus fees)
        expect(received).to.be.lte(withdrawAmount);
      } catch (error: any) {
        // If it reverts, should be due to slippage check
        expect(error.message).to.include("SlippageCheckFailed");
      }
    });
  });
});