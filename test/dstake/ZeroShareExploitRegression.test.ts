import { expect } from "chai";
import { ethers, deployments, getNamedAccounts } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import {
  DStakeRouterV2,
  MockMetaMorphoVault,
  ERC20StablecoinUpgradeable,
  DStakeCollateralVaultV2,
  MetaMorphoConversionAdapter,
  DStakeTokenV2,
} from "../../typechain-types";
import { configureMetaMorphoRouter, ensureRole } from "./utils/configureMetaMorpho";

describe("Zero Share Exploit Regression Test", function () {
  let owner: SignerWithAddress;
  let attacker: SignerWithAddress;
  let victim: SignerWithAddress;

  let dStable: ERC20StablecoinUpgradeable;
  let router: DStakeRouterV2;
  let collateralVault: DStakeCollateralVaultV2;
  let dStakeToken: DStakeTokenV2;
  let vault: MockMetaMorphoVault;
  let adapter: MetaMorphoConversionAdapter;

  beforeEach(async function () {
    // Deploy fresh contracts
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    [owner, attacker, victim] = await ethers.getSigners();
    const namedAccounts = await getNamedAccounts();

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeTokenV2_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVaultV2_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeTokenV2", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVaultV2", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    vault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    adapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    await configureMetaMorphoRouter({
      router,
      routerDeployment,
      collateralVault,
      collateralVaultDeployment,
      vault,
      adapter,
      operator: owner,
      namedAccounts,
    });

    const minterRole = await dStable.MINTER_ROLE();
    await ensureRole({ contract: dStable, deployment: dStableDeployment, role: minterRole, operator: owner, namedAccounts });

    const tokenDefaultAdmin = await dStakeToken.DEFAULT_ADMIN_ROLE();
    await ensureRole({ contract: dStakeToken, deployment: dStakeTokenDeployment, role: tokenDefaultAdmin, operator: owner, namedAccounts });

    // Setup initial state to create PPS > 1
    // Mint tokens to victim and have them deposit
    await dStable.connect(owner).mint(victim.address, ethers.parseEther("1000"));
    await dStable.connect(victim).approve(await dStakeToken.getAddress(), ethers.MaxUint256);
    await dStakeToken.connect(victim).deposit(ethers.parseEther("100"), victim.address);

    // Increase PPS by adding yield directly
    await dStable.connect(owner).mint(await dStakeToken.getAddress(), ethers.parseEther("50"));

    // Give attacker some funds and shares
    await dStable.connect(owner).mint(attacker.address, ethers.parseEther("10"));
    await dStable.connect(attacker).approve(await dStakeToken.getAddress(), ethers.MaxUint256);
    await dStakeToken.connect(attacker).deposit(ethers.parseEther("1"), attacker.address);

    // Ensure collateral vault has vault shares for withdrawals
    // The vault mint function requires the caller to provide assets, so give the owner the assets
    const mintShares = ethers.parseEther("200");
    const requiredAssets = await vault.previewMint(mintShares);
    const buffer = requiredAssets / 10000n + 1n;
    const assetsForMint = requiredAssets + buffer;
    await dStable.connect(owner).mint(owner.address, assetsForMint);
    await dStable.connect(owner).approve(await vault.getAddress(), assetsForMint);
    // Then mint vault shares to the collateral vault
    await vault.mint(mintShares, await collateralVault.getAddress());
  });

  describe("Zero Share Withdrawal Exploit Prevention", function () {
    it("Should prevent zero-share withdrawals that drain collateral", async function () {
      // Verify PPS >= 1 with a small tolerance due to initial conditions
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();
      expect(totalAssets).to.be.gte(totalSupply);

      // Attacker tries to withdraw tiny vault shares that would round to 0 dSTAKE shares
      const tinyVaultShares = 1n; // 1 wei of vault shares

      // Attack should fail with the fix
      await expect(
        router.connect(attacker).solverWithdrawShares(
          [await vault.getAddress()],
          [tinyVaultShares],
          0, // maxShares = 0 (exploit attempt)
          attacker.address,
          attacker.address
        )
      ).to.be.revertedWithCustomError(router, "SharesExceedMaxRedeem");
    });

    it("Should allow legitimate withdrawals with proper share burning", async function () {
      // Get attacker's share balance before
      const sharesBefore = await dStakeToken.balanceOf(attacker.address);
      expect(sharesBefore).to.be.gt(0);

      // Legitimate withdrawal with reasonable vault shares
      const reasonableVaultShares = ethers.parseEther("0.1");

      // This should work and burn shares
      await router.connect(attacker).solverWithdrawShares(
        [await vault.getAddress()],
        [reasonableVaultShares],
        ethers.MaxUint256, // Don't constrain shares to avoid rounding-induced reverts
        attacker.address,
        attacker.address
      );

      // Verify shares were burned
      const sharesAfter = await dStakeToken.balanceOf(attacker.address);
      expect(sharesAfter).to.be.lt(sharesBefore);
    });

    it("Should use ceiling rounding to prevent exploitation", async function () {
      // Test that even amounts that would round down to 0 with floor rounding
      // are caught by the fix

      // Calculate an amount that when converted to shares would be < 1
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();

      // Find vault shares that would withdraw less than 1 share's worth of assets
      // This would round to 0 shares with floor rounding
      const vaultShares = 10n; // Very small amount

      // This should revert due to zero share protection
      await expect(
        router.connect(attacker).solverWithdrawShares([await vault.getAddress()], [vaultShares], 0, attacker.address, attacker.address)
      ).to.be.revertedWithCustomError(router, "SharesExceedMaxRedeem");
    });
  });
});
