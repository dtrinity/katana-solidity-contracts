import { expect } from "chai";
import { ethers, deployments } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import {
  DStakeRouterV2,
  MockMetaMorphoVault,
  TestMintableERC20,
  DStakeCollateralVault,
  MetaMorphoConversionAdapter,
  DStakeToken
} from "../../typechain-types";

describe("Zero Share Exploit Regression Test", function () {
  let owner: SignerWithAddress;
  let attacker: SignerWithAddress;
  let victim: SignerWithAddress;

  let dStable: TestMintableERC20;
  let router: DStakeRouterV2;
  let collateralVault: DStakeCollateralVault;
  let dStakeToken: DStakeToken;
  let vault: MockMetaMorphoVault;
  let adapter: MetaMorphoConversionAdapter;

  beforeEach(async function () {
    // Deploy fresh contracts
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    [owner, attacker, victim] = await ethers.getSigners();

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeToken_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVault_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_sdUSD");

    dStable = await ethers.getContractAt("TestMintableERC20", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeToken", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVault", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    vault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    adapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    // Setup permissions and configuration
    const MINTER_ROLE = await dStable.MINTER_ROLE();
    await dStable.connect(owner).grantRole(MINTER_ROLE, owner.address);

    // Configure router with vault
    const VAULT_MANAGER_ROLE = await router.VAULT_MANAGER_ROLE();
    const hasRole = await router.hasRole(VAULT_MANAGER_ROLE, owner.address);
    if (!hasRole) {
      // Get governance account to grant role
      const DEFAULT_ADMIN_ROLE = await router.DEFAULT_ADMIN_ROLE();
      const adminCount = await router.getRoleMemberCount(DEFAULT_ADMIN_ROLE);
      if (adminCount > 0) {
        const admin = await router.getRoleMember(DEFAULT_ADMIN_ROLE, 0);
        const adminSigner = await ethers.getImpersonatedSigner(admin);
        await owner.sendTransaction({ to: admin, value: ethers.utils.parseEther("1") });
        await router.connect(adminSigner).grantRole(VAULT_MANAGER_ROLE, owner.address);
      }
    }

    // Add vault configuration if not already configured
    const vaultCount = await router.getVaultCount();
    if (vaultCount.eq(0)) {
      await router.connect(owner).addVaultConfig(
        vault.address,
        adapter.address,
        10000, // 100% allocation
        true
      );
    }

    // Setup initial state to create PPS > 1
    // Mint tokens to victim and have them deposit
    await dStable.connect(owner).mint(victim.address, ethers.utils.parseEther("1000"));
    await dStable.connect(victim).approve(dStakeToken.address, ethers.constants.MaxUint256);
    await dStakeToken.connect(victim).deposit(ethers.utils.parseEther("100"), victim.address);

    // Increase PPS by adding yield directly
    await dStable.connect(owner).mint(dStakeToken.address, ethers.utils.parseEther("50"));

    // Give attacker some funds and shares
    await dStable.connect(owner).mint(attacker.address, ethers.utils.parseEther("10"));
    await dStable.connect(attacker).approve(dStakeToken.address, ethers.constants.MaxUint256);
    await dStakeToken.connect(attacker).deposit(ethers.utils.parseEther("1"), attacker.address);

    // Ensure collateral vault has vault shares for withdrawals
    await vault.mint(collateralVault.address, ethers.utils.parseEther("200"));
  });

  describe("Zero Share Withdrawal Exploit Prevention", function () {
    it("Should prevent zero-share withdrawals that drain collateral", async function () {
      // Verify PPS > 1
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();
      expect(totalAssets).to.be.gt(totalSupply);

      // Attacker tries to withdraw tiny vault shares that would round to 0 dSTAKE shares
      const tinyVaultShares = ethers.BigNumber.from("1"); // 1 wei of vault shares

      // Attack should fail with the fix
      await expect(
        dStakeToken.connect(attacker).solverWithdrawShares(
          [vault.address],
          [tinyVaultShares],
          0, // maxShares = 0 (exploit attempt)
          attacker.address,
          attacker.address
        )
      ).to.be.revertedWith("ZeroShares");
    });

    it("Should allow legitimate withdrawals with proper share burning", async function () {
      // Get attacker's share balance before
      const sharesBefore = await dStakeToken.balanceOf(attacker.address);
      expect(sharesBefore).to.be.gt(0);

      // Legitimate withdrawal with reasonable vault shares
      const reasonableVaultShares = ethers.utils.parseEther("0.1");

      // This should work and burn shares
      await dStakeToken.connect(attacker).solverWithdrawShares(
        [vault.address],
        [reasonableVaultShares],
        sharesBefore, // Use actual shares as max
        attacker.address,
        attacker.address
      );

      // Verify shares were burned
      const sharesAfter = await dStakeToken.balanceOf(attacker.address);
      expect(sharesAfter).to.be.lt(sharesBefore);
    });

    it("Should use ceiling rounding to prevent exploitation", async function () {
      // Test that even amounts that would round down to 0 with floor rounding
      // are caught by the fix

      // Calculate an amount that when converted to shares would be < 1
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();

      // Find vault shares that would withdraw less than 1 share's worth of assets
      // This would round to 0 shares with floor rounding
      const vaultShares = ethers.BigNumber.from("10"); // Very small amount

      // This should revert due to zero share protection
      await expect(
        dStakeToken.connect(attacker).solverWithdrawShares(
          [vault.address],
          [vaultShares],
          0,
          attacker.address,
          attacker.address
        )
      ).to.be.revertedWith("ZeroShares");
    });
  });
});