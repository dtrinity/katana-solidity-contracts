import { expect } from "chai";
import { ethers, deployments } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import {
  DStakeRouterV2,
  MockMetaMorphoVault,
  ERC20StablecoinUpgradeable,
  DStakeCollateralVault,
  MetaMorphoConversionAdapter,
  DStakeToken
} from "../../typechain-types";

describe("Zero Share Exploit Regression Test", function () {
  let owner: SignerWithAddress;
  let attacker: SignerWithAddress;
  let victim: SignerWithAddress;

  let dStable: ERC20StablecoinUpgradeable;
  let router: DStakeRouterV2;
  let collateralVault: DStakeCollateralVault;
  let dStakeToken: DStakeToken;
  let vault: MockMetaMorphoVault;
  let adapter: MetaMorphoConversionAdapter;

  beforeEach(async function () {
    // Deploy fresh contracts
    await deployments.fixture(["dusd", "dStake", "mock-metamorpho-vaults", "metamorpho-adapters", "test-permissions"]);

    [owner, attacker, victim] = await ethers.getSigners();

    // Get deployed contracts
    const dStableDeployment = await deployments.get("dUSD");
    const dStakeTokenDeployment = await deployments.get("DStakeToken_sdUSD");
    const collateralVaultDeployment = await deployments.get("DStakeCollateralVault_sdUSD");
    const routerDeployment = await deployments.get("DStakeRouterV2_sdUSD");
    const vaultDeployment = await deployments.get("MockMetaMorphoVault_dUSD");
    const adapterDeployment = await deployments.get("MetaMorphoConversionAdapter_dUSD");

    dStable = await ethers.getContractAt("ERC20StablecoinUpgradeable", dStableDeployment.address);
    dStakeToken = await ethers.getContractAt("DStakeToken", dStakeTokenDeployment.address);
    collateralVault = await ethers.getContractAt("DStakeCollateralVault", collateralVaultDeployment.address);
    router = await ethers.getContractAt("DStakeRouterV2", routerDeployment.address);
    vault = await ethers.getContractAt("MockMetaMorphoVault", vaultDeployment.address);
    adapter = await ethers.getContractAt("MetaMorphoConversionAdapter", adapterDeployment.address);

    // Setup permissions and configuration
    const MINTER_ROLE = await dStable.MINTER_ROLE();
    await dStable.connect(owner).grantRole(MINTER_ROLE, owner.address);

    // Configure router with vault
    const VAULT_MANAGER_ROLE = await router.VAULT_MANAGER_ROLE();
    const ADAPTER_MANAGER_ROLE = await router.ADAPTER_MANAGER_ROLE();
    const CONFIG_MANAGER_ROLE = await router.CONFIG_MANAGER_ROLE();
    const ROUTER_DEFAULT_ADMIN_ROLE = await router.DEFAULT_ADMIN_ROLE();
    const hasAdminRole = await router.hasRole(ROUTER_DEFAULT_ADMIN_ROLE, owner.address);
    let routerAdminSigner = owner;
    if (!hasAdminRole) {
      const routerAdmin = routerDeployment.receipt?.from;
      if (!routerAdmin) {
        throw new Error("Unable to determine router admin");
      }
      routerAdminSigner = await ethers.getImpersonatedSigner(routerAdmin);
      await owner.sendTransaction({ to: routerAdmin, value: ethers.parseEther("1") });
    }

    if (!(await router.hasRole(VAULT_MANAGER_ROLE, owner.address))) {
      await router.connect(routerAdminSigner).grantRole(VAULT_MANAGER_ROLE, owner.address);
    }
    if (!(await router.hasRole(ADAPTER_MANAGER_ROLE, owner.address))) {
      await router.connect(routerAdminSigner).grantRole(ADAPTER_MANAGER_ROLE, owner.address);
    }
    if (!(await router.hasRole(CONFIG_MANAGER_ROLE, owner.address))) {
      await router.connect(routerAdminSigner).grantRole(CONFIG_MANAGER_ROLE, owner.address);
    }

    const strategyShareAddress = await vault.getAddress();
    const adapterAddress = await adapter.getAddress();

    if ((await router.strategyShareToAdapter(strategyShareAddress)) === ethers.ZeroAddress) {
      await router.connect(owner).addAdapter(strategyShareAddress, adapterAddress);
    }

    if (!(await router.vaultExists(strategyShareAddress))) {
      await router.connect(owner).addVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    } else {
      await router.connect(owner).updateVaultConfig(strategyShareAddress, adapterAddress, 10000, true);
    }

    await router.connect(owner).setDefaultDepositStrategyShare(strategyShareAddress);

    // Setup initial state to create PPS > 1
    // Mint tokens to victim and have them deposit
    await dStable.connect(owner).mint(victim.address, ethers.parseEther("1000"));
    await dStable.connect(victim).approve(await dStakeToken.getAddress(), ethers.MaxUint256);
    await dStakeToken.connect(victim).deposit(ethers.parseEther("100"), victim.address);

    // Increase PPS by adding yield directly
    await dStable.connect(owner).mint(await dStakeToken.getAddress(), ethers.parseEther("50"));

    // Give attacker some funds and shares
    await dStable.connect(owner).mint(attacker.address, ethers.parseEther("10"));
    await dStable.connect(attacker).approve(await dStakeToken.getAddress(), ethers.MaxUint256);
    await dStakeToken.connect(attacker).deposit(ethers.parseEther("1"), attacker.address);

    // Ensure collateral vault has vault shares for withdrawals
    // The vault mint function requires the caller to provide assets, so give the owner the assets
    const mintShares = ethers.parseEther("200");
    const requiredAssets = await vault.previewMint(mintShares);
    const buffer = requiredAssets / 10000n + 1n;
    const assetsForMint = requiredAssets + buffer;
    await dStable.connect(owner).mint(owner.address, assetsForMint);
    await dStable.connect(owner).approve(await vault.getAddress(), assetsForMint);
    // Then mint vault shares to the collateral vault
    await vault.mint(mintShares, await collateralVault.getAddress());
  });

  describe("Zero Share Withdrawal Exploit Prevention", function () {
    it("Should prevent zero-share withdrawals that drain collateral", async function () {
      // Verify PPS > 1
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();
      expect(totalAssets).to.be.gt(totalSupply);

      // Attacker tries to withdraw tiny vault shares that would round to 0 dSTAKE shares
      const tinyVaultShares = 1n; // 1 wei of vault shares

      // Attack should fail with the fix
      await expect(
        dStakeToken.connect(attacker).solverWithdrawShares(
          [await vault.getAddress()],
          [tinyVaultShares],
          0, // maxShares = 0 (exploit attempt)
          attacker.address,
          attacker.address
        )
      ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxRedeem");
    });

    it("Should allow legitimate withdrawals with proper share burning", async function () {
      // Get attacker's share balance before
      const sharesBefore = await dStakeToken.balanceOf(attacker.address);
      expect(sharesBefore).to.be.gt(0);

      // Legitimate withdrawal with reasonable vault shares
      const reasonableVaultShares = ethers.parseEther("0.1");

      // This should work and burn shares
      await dStakeToken.connect(attacker).solverWithdrawShares(
        [await vault.getAddress()],
        [reasonableVaultShares],
        sharesBefore, // Use actual shares as max
        attacker.address,
        attacker.address
      );

      // Verify shares were burned
      const sharesAfter = await dStakeToken.balanceOf(attacker.address);
      expect(sharesAfter).to.be.lt(sharesBefore);
    });

    it("Should use ceiling rounding to prevent exploitation", async function () {
      // Test that even amounts that would round down to 0 with floor rounding
      // are caught by the fix

      // Calculate an amount that when converted to shares would be < 1
      const totalAssets = await dStakeToken.totalAssets();
      const totalSupply = await dStakeToken.totalSupply();

      // Find vault shares that would withdraw less than 1 share's worth of assets
      // This would round to 0 shares with floor rounding
      const vaultShares = 10n; // Very small amount

      // This should revert due to zero share protection
      await expect(
        dStakeToken.connect(attacker).solverWithdrawShares(
          [await vault.getAddress()],
          [vaultShares],
          0,
          attacker.address,
          attacker.address
        )
      ).to.be.revertedWithCustomError(dStakeToken, "ERC4626ExceedsMaxRedeem");
    });
  });
});
